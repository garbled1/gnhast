/*
 * Copyright (c) 2014
 *      Tim Rightnour.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Tim Rightnour may not be used to endorse or promote 
 *    products derived from this software without specific prior written 
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TIM RIGHTNOUR ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL TIM RIGHTNOUR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
   \file interface.c
   \brief Widget handling code for gtk-gnhast
   \author Tim Rightnour
   Initially generated by glade-2
*/

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/queue.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

#include <gdk/gdkkeysyms.h>
#include <gtk/gtk.h>

#include "gnhast.h"
#include "common.h"
#include "confuse.h"
#include "confparser.h"
#include "gncoll.h"
#include "collcmd.h"
#include "gtk-gnhast.h"

#include "callbacks.h"
#include "interface.h"
#include "support.h"

extern TAILQ_HEAD(, _device_t) alldevs;
extern TAILQ_HEAD(, _device_group_t) allgroups;
extern name_map_t devsubtype_map[];
extern name_map_t devproto_map[];
extern name_map_t devtype_map[];
extern GtkWidget *main_window;
extern int debugmode;

#define GLADE_HOOKUP_OBJECT(component,widget,name) \
  g_object_set_data_full (G_OBJECT (component), name, \
    gtk_widget_ref (widget), (GDestroyNotify) gtk_widget_unref)

#define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
  g_object_set_data (G_OBJECT (component), name, widget)

GtkTreeModel *devicetree_model = NULL;
GtkTreeModel *devicelist_model = NULL;
GtkTreeModel *iconview_model = NULL;
GdkPixbuf *subtype_icons[NROF_SUBTYPES];
GdkPixbuf *group_icon;
GtkTreeSelection *dd_select, *overview_select;

dd_field_t dd_fields[NROF_DD] = {
	{NULL, NULL, NULL, FALSE,},
	{NULL, "UID", NULL, FALSE,},
	{NULL, "Name", NULL, TRUE,},
	{NULL, "RRDName", NULL, TRUE,},
	{NULL, "SubType", NULL, FALSE,},
	{NULL, "Type", NULL, FALSE,},
	{NULL, "Protocol", NULL, FALSE,},
	{NULL, "Scale", NULL, TRUE,},
	{NULL, "Handler", NULL, TRUE,},
	{NULL, "Handler Args", NULL, TRUE,},
	{NULL, "HiWaterMark", NULL, TRUE,},
	{NULL, "LoWaterMark", NULL, TRUE,},
	{NULL, "Current Value", NULL, FALSE,},
};

GtkTargetEntry drag_targets[] = {
	{ "device_group", 0, 0 }
};

/**
   \brief Load the icons
*/

static void load_icons(void)
{
	subtype_icons[SUBTYPE_NONE] = create_pixbuf("gnhast-icon-32.png");
	subtype_icons[SUBTYPE_SWITCH] = create_pixbuf("switch.png");
	subtype_icons[SUBTYPE_OUTLET] = create_pixbuf("outlet.png");
	subtype_icons[SUBTYPE_TEMP] = create_pixbuf("temp.png");
	subtype_icons[SUBTYPE_HUMID] = create_pixbuf("humid.png");
	subtype_icons[SUBTYPE_COUNTER] = create_pixbuf("counter.png");
	subtype_icons[SUBTYPE_PRESSURE] = create_pixbuf("pressure.png");
	subtype_icons[SUBTYPE_SPEED] = create_pixbuf("speed.png");
	subtype_icons[SUBTYPE_DIR] = create_pixbuf("dir.png");
	subtype_icons[SUBTYPE_MOISTURE] = create_pixbuf("moisture.png");
	subtype_icons[SUBTYPE_WETNESS] = create_pixbuf("wetness.png");
	subtype_icons[SUBTYPE_HUB] = create_pixbuf("hub.png");
	subtype_icons[SUBTYPE_LUX] = create_pixbuf("lux.png");
	subtype_icons[SUBTYPE_VOLTAGE] = create_pixbuf("voltage.png");
	subtype_icons[SUBTYPE_WATTSEC] = create_pixbuf("wattsec.png");
	subtype_icons[SUBTYPE_WATT] = create_pixbuf("watt.png");
	subtype_icons[SUBTYPE_AMPS] = create_pixbuf("amps.png");
	subtype_icons[SUBTYPE_RAINRATE] = create_pixbuf("rainrate.png");
	subtype_icons[SUBTYPE_WEATHER] = create_pixbuf("weather.png");
	subtype_icons[SUBTYPE_ALARMSTATUS] = create_pixbuf("alarmstatus.png");
	subtype_icons[SUBTYPE_NUMBER] = create_pixbuf("number.png");
	subtype_icons[SUBTYPE_PERCENTAGE] = create_pixbuf("percent.png");
	subtype_icons[SUBTYPE_FLOWRATE] = create_pixbuf("flowrate.png");
	subtype_icons[SUBTYPE_DISTANCE] = create_pixbuf("distance.png");
	subtype_icons[SUBTYPE_VOLUME] = create_pixbuf("volume.png");
	subtype_icons[SUBTYPE_TIMER] = create_pixbuf("timer.png");
	subtype_icons[SUBTYPE_THMODE] = create_pixbuf("thmode.png");
	subtype_icons[SUBTYPE_THSTATE] = create_pixbuf("thstate.png");
	subtype_icons[SUBTYPE_SMNUMBER] = create_pixbuf("smnumber.png");
	subtype_icons[SUBTYPE_BOOL] = create_pixbuf("switch.png");
	group_icon = create_pixbuf("group.png");
}

/**
   \brief Is a uid a dev or a group?
   \param uid uid string
   \return enum of UID_IS
*/

int what_is_uid(char *uid)
{
	if (find_device_byuid(uid) != NULL)
		return UID_IS_DEV;
	if (find_devgroup_byuid(uid) != NULL)
		return UID_IS_GROUP;
	return UID_IS_NULL;
}

/**
   \brief Search the current level for a matching uid
   \param model model to search
   \param level parent node of tree to search
   \param child found child
   \param uid uid to look for
   \return true or false if found
*/

gboolean find_uid_in_devicetree_at_level(GtkTreeModel *model,
					 GtkTreeIter *level,
					 GtkTreeIter *child,
					 char *uid)
{
	gboolean valid;
	char *checkuid;

	if (uid == NULL)
		return FALSE;

	valid = gtk_tree_model_iter_children(model, child, level);
	while (valid) {
		gtk_tree_model_get(model, child, UID_COLUMN, &checkuid, -1);
		if (checkuid && strlen(uid) == strlen(checkuid) &&
		    strcmp(uid, checkuid) == 0) {
			g_free(checkuid);
			return TRUE;
		} else
			g_free(checkuid);
		valid = gtk_tree_model_iter_next(model, child);
	}
	return FALSE;
}


/**
   \brief Update device tree model with data
   \param devgrp Group to add
   \param model model to add to
   \param level tree item to add to
*/

void add_group_devicetree_model(device_group_t *devgrp,	GtkTreeModel *model,
				GtkTreeIter *level)
{
	GtkTreeIter item, child;
	wrap_device_t *wdev;
	device_group_t *cgrp;
	wrap_group_t *wgrp;

	if (!find_uid_in_devicetree_at_level(model, level, &child,
					     devgrp->uid))
		gtk_tree_store_append(GTK_TREE_STORE(model),
				      &child, level);

	gtk_tree_store_set(GTK_TREE_STORE(model), &child,
			   NAME_COLUMN, devgrp->name,
			   UID_COLUMN, devgrp->uid, -1);

	TAILQ_FOREACH(wdev, &devgrp->members, next) {
		if (!find_uid_in_devicetree_at_level(model, &child, &item,
						     wdev->dev->uid))
			gtk_tree_store_append(GTK_TREE_STORE(model),
					      &item, &child);
		gtk_tree_store_set(GTK_TREE_STORE(model), &item,
				   NAME_COLUMN, wdev->dev->name,
				   UID_COLUMN, wdev->dev->uid, -1);
	}
	TAILQ_FOREACH(wgrp, &devgrp->children, nextg)
		add_group_devicetree_model(wgrp->group, model, &child);
}

/**
   \brief update the devicetree_model with the contents of the device tree
*/

void update_devicetree_model(GtkTreeModel *model)
{
	device_group_t *devgrp;
	device_t *dev;
	GtkTreeIter item, toplevel;

	TAILQ_FOREACH(devgrp, &allgroups, next_all) {
		/* Look for head nodes */
		if (!devgrp->subgroup) {
			TLOG(LOG_DEBUG, "appending grp uid:%s name:%s",
			     devgrp->uid, devgrp->name);
			add_group_devicetree_model(devgrp, model, NULL);
		}
	}

	/* build a tree of all devices */
	if (!find_uid_in_devicetree_at_level(model, NULL, &toplevel,
					     INVALID_UID))
		gtk_tree_store_append(GTK_TREE_STORE(model),
				      &toplevel, NULL);
	gtk_tree_store_set(GTK_TREE_STORE(model), &toplevel,
			   NAME_COLUMN, "All Devices",
			   UID_COLUMN, INVALID_UID, -1);

	TAILQ_FOREACH(dev, &alldevs, next_all) {
		if (!find_uid_in_devicetree_at_level(model, &toplevel, &item,
						     dev->uid))
			gtk_tree_store_append(GTK_TREE_STORE(model),
					      &item, &toplevel);
		gtk_tree_store_set(GTK_TREE_STORE(model), &item,
				   NAME_COLUMN, dev->name,
				   UID_COLUMN, dev->uid, -1);
	}
}

/**
   \brief Build the devicetree view
*/

GtkWidget *create_devicetree_view_and_model()
{
	GtkTreeViewColumn *col1, *col2;
	GtkCellRenderer *renderer;
	GtkWidget *view;

	view = gtk_tree_view_new();
	col1 = gtk_tree_view_column_new();
	gtk_tree_view_column_set_title(col1, "Device Tree");
	gtk_tree_view_append_column(GTK_TREE_VIEW(view), col1);

	renderer = gtk_cell_renderer_text_new();
	gtk_tree_view_column_pack_start(col1, renderer, TRUE);
	gtk_tree_view_column_add_attribute(col1, renderer, "text", 0);

	col2 = gtk_tree_view_column_new();
	gtk_tree_view_append_column(GTK_TREE_VIEW(view), col2);
	gtk_tree_view_column_set_visible(col2, FALSE);

	if (devicetree_model == NULL)
		devicetree_model = GTK_TREE_MODEL(gtk_tree_store_new(2, G_TYPE_STRING, G_TYPE_STRING));
	gtk_tree_view_set_model(GTK_TREE_VIEW(view), devicetree_model);

	return view;
}

/**
   \brief Find the model/iter pair in the list view by uid
   \param model pointer to model
   \param iter pointer to iter
   \param devuid the uid to find
   \param widgetname the widget to find, by name
   \return TRUE if found, FALSE if not
*/

gboolean find_listview_iter_byuid(GtkTreeModel **model, GtkTreeIter *iter,
				  char *devuid, char *widgetname)
{
	GtkWidget *widget;
	char *uid;
	gboolean valid;

	widget = lookup_widget(main_window, widgetname);
	if (widget == NULL || devuid == NULL)
		return FALSE;

	if (GTK_IS_TREE_VIEW(widget)) {
		*model = gtk_tree_view_get_model(GTK_TREE_VIEW(widget));
	} else {
		*model = gtk_icon_view_get_model(GTK_ICON_VIEW(widget));
	}
	if (*model == NULL)
		return FALSE;

	valid = gtk_tree_model_get_iter_first(*model, iter);
	while (valid) {
		gtk_tree_model_get(*model, iter, LIST_UID_COL, &uid, -1);
		if (uid != NULL && strlen(uid) == strlen(devuid) &&
		    strcmp(uid, devuid) == 0) {
			g_free(uid);
			return TRUE;
		} else
			g_free(uid);
		valid = gtk_tree_model_iter_next(*model, iter);
	}

	return FALSE;
}

#define BUILD_LIST_COL(col, num, title, visible)			\
	col[num] = gtk_tree_view_column_new();				\
	gtk_tree_view_column_set_title(col[num], title);		\
	gtk_tree_view_append_column(GTK_TREE_VIEW(view), col[num]);	\
	gtk_tree_view_column_set_visible(col[num], visible);		\
	renderer = gtk_cell_renderer_text_new();			\
	gtk_tree_view_column_pack_start(col[num], renderer, TRUE);	\
	gtk_tree_view_column_add_attribute(col[num], renderer, "text", num);

/**
   \brief Build the devicetree view
   \param view the view to build
   \param do_pixbuf TRUE/FALSE to display the pixbuf column
*/

static void create_list_view(GtkWidget *view, gboolean do_pixbuf)
{
	GtkTreeViewColumn *col[LIST_NUM_COLS];
	GtkCellRenderer *renderer;

	BUILD_LIST_COL(col, LIST_NAME_COL, "Device Name", TRUE);
	BUILD_LIST_COL(col, LIST_UID_COL, "Device UID", TRUE);

	col[LIST_PIXBUF_COL] = gtk_tree_view_column_new();
	gtk_tree_view_column_set_title(col[LIST_PIXBUF_COL], "Icon");
	gtk_tree_view_append_column(GTK_TREE_VIEW(view), col[LIST_PIXBUF_COL]);
	gtk_tree_view_column_set_visible(col[LIST_PIXBUF_COL], do_pixbuf);
	renderer = gtk_cell_renderer_pixbuf_new();
	gtk_tree_view_column_pack_start(col[LIST_PIXBUF_COL], renderer, TRUE);
	gtk_tree_view_column_add_attribute(col[LIST_PIXBUF_COL], renderer,
					   "pixbuf", LIST_PIXBUF_COL);

	BUILD_LIST_COL(col, LIST_VALUE_COL, "Device Reading", TRUE);
	BUILD_LIST_COL(col, LIST_TYPE_COL, "Device Type", TRUE);
	BUILD_LIST_COL(col, LIST_PROTO_COL, "Device Protocol", TRUE);
	BUILD_LIST_COL(col, LIST_SUBTYPE_COL, "Device Subtype", TRUE);
}

/**
   \brief Build the list view model
*/

static GtkTreeModel *create_listview_model(void)
{
	GtkListStore *list;

	list = gtk_list_store_new(LIST_NUM_COLS, G_TYPE_STRING, G_TYPE_STRING,
				  GDK_TYPE_PIXBUF, G_TYPE_STRING,
				  G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
	return GTK_TREE_MODEL(list);
}

/**
   \brief Update device list model with group data
   \param devgrp Group to add
   \param model model to add to
   \param level tree item to add to
   \param widgetname widget name to add to
*/

static void add_group_devicelist_model(device_group_t *devgrp,
				       GtkTreeModel *model,
				       GtkTreeIter *level, char *widgetname)
{
	GtkTreeModel *tmodel;
	GtkTreeIter titer;

	/* check if item exists */
	if (find_listview_iter_byuid(&tmodel, &titer, devgrp->uid, widgetname))
		return;

	gtk_list_store_append(GTK_LIST_STORE(model), level);
	gtk_list_store_set(GTK_LIST_STORE(model), level,
			   LIST_NAME_COL, devgrp->name,
			   LIST_UID_COL, devgrp->uid,
			   LIST_PIXBUF_COL, group_icon,
			   LIST_VALUE_COL, "GROUP",
			   LIST_TYPE_COL, "GROUP",
			   LIST_PROTO_COL, "GROUP",
			   LIST_SUBTYPE_COL, "GROUP", -1);
}

/**
   \brief Update device list model with device data
   \param dev device to add
   \param model model to add to
   \param level tree item to add to
   \param widgetname the widget name to add to
*/

static void add_device_devicelist_model(device_t *dev,
					GtkTreeModel *model,
					GtkTreeIter *level, char *widgetname)
{
	GtkTreeModel *tmodel;
	GtkTreeIter titer;

	/* check if item exists */
	if (find_listview_iter_byuid(&tmodel, &titer, dev->uid, widgetname))
		return;

	gtk_list_store_append(GTK_LIST_STORE(model), level);
	gtk_list_store_set(GTK_LIST_STORE(model), level,
			   LIST_NAME_COL, dev->name,
			   LIST_UID_COL, dev->uid,
			   LIST_PIXBUF_COL, subtype_icons[dev->subtype],
			   LIST_VALUE_COL, "UNKNOWN",
			   LIST_TYPE_COL, devtype_map[dev->type].name,
			   LIST_PROTO_COL, devproto_map[dev->proto].name,
			   LIST_SUBTYPE_COL, devsubtype_map[dev->subtype].name,
			   -1);
}


/**
   \brief update the devicelist_model with the contents of the device tree
*/

void update_devicelist_model(GtkTreeModel *model)
{
	device_group_t *devgrp;
	device_t *dev;
	GtkTreeIter item;

	/* first all the groups */
	TAILQ_FOREACH(devgrp, &allgroups, next_all) {
		add_group_devicelist_model(devgrp, model, &item, "treeview1");
	}

	/* now all devices */
	TAILQ_FOREACH(dev, &alldevs, next_all) {
		add_device_devicelist_model(dev, model, &item, "treeview1");
	}
}

/**
   \brief Update all value fields in scope
   \param dev device to update for
*/

void update_all_vals_dev(device_t *dev)
{
	GtkWidget *widget;
	GtkTreeIter iter;
	GtkTreeModel *model;
	char *uid, *buf;

	if (dev == NULL)
		return;

	buf = print_data_dev(dev, DATALOC_DATA);
	if (buf == NULL)
		return;

	/* do the device details view */
	if (gtk_tree_selection_get_selected(overview_select, &model, &iter)) {
		gtk_tree_model_get(model, &iter, UID_COLUMN, &uid, -1);
		if (strcmp(uid, dev->uid) == 0)
			gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_VALUE].entry), buf);
	}

	/* Now the list view */
	if (find_listview_iter_byuid(&model, &iter, dev->uid, "treeview1")) {
		gtk_list_store_set(GTK_LIST_STORE(model), &iter,
				   LIST_VALUE_COL, buf, -1);
	}

	free(buf);
	return;			
}


/**
   \brief Update the device detail pane with a device
   \param dev device
*/

void update_dd_dev(device_t *dev)
{
	char buf[2048], buf2[256], *dbuf;
	int i;

	if (dev == NULL)
		return;

	if (dev->uid)
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_UID].entry),
				   dev->uid);
	else
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_UID].entry), "");

	if (dev->name)
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_NAME].entry),
				   dev->name);
	else
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_NAME].entry), "");
	
	if (dev->rrdname)
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_RRDNAME].entry),
				   dev->rrdname);
	else
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_RRDNAME].entry), "");

	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_SUBTYPE].entry),
			   devsubtype_map[dev->subtype].name);
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_TYPE].entry),
			   devtype_map[dev->type].name);
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_PROTO].entry),
			   devproto_map[dev->proto].name);
	sprintf(buf, "%d", dev->scale);
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_SCALE].entry), buf);
	if (dev->handler)
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_HANDLER].entry),
				   dev->handler);
	else
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_HANDLER].entry), "");

	if (dev->hargs && dev->hargs[0]) {
		sprintf(buf, "%s", dev->hargs[0]);
		for (i=1; i < dev->nrofhargs; i++) {
			sprintf(buf2, ",%s", dev->hargs[i]);
			strcat(buf, buf2);
		}
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_HARGS].entry),
				   buf);
	} else
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_HARGS].entry), "");

	dbuf = print_data_dev(dev, DATALOC_HIWAT);
	if (dbuf) {
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_HIWAT].entry), dbuf);
		free(dbuf);
	}
	dbuf = print_data_dev(dev, DATALOC_LOWAT);
	if (dbuf) {
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_LOWAT].entry), dbuf);
		free(dbuf);
	}
	dbuf = print_data_dev(dev, DATALOC_DATA);
	if (dbuf) {
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_VALUE].entry), dbuf);
		free(dbuf);
	}
}

/**
   \brief Update the device detail pane with a device group
   \param dev device
*/

void update_dd_devgrp(device_group_t *devgrp)
{

	if (devgrp == NULL)
		return;

	if (devgrp->uid)
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_UID].entry),
				   devgrp->uid);
	else
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_UID].entry), "");

	if (devgrp->name)
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_NAME].entry),
				   devgrp->name);
	else
		gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_NAME].entry), "");
	
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_RRDNAME].entry), "N/A");
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_SUBTYPE].entry), "GROUP");
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_TYPE].entry), "GROUP");
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_PROTO].entry), "GROUP");
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_SCALE].entry), "N/A");
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_HANDLER].entry), "N/A");
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_HARGS].entry), "N/A");
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_HIWAT].entry), "N/A");
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_LOWAT].entry), "N/A");
	gtk_entry_set_text(GTK_ENTRY(dd_fields[DD_VALUE].entry), "N/A");
}

/**
   \brief Add devices to the iconview
   \param uid uid of parent
*/

void update_iconview(char *uid)
{
	gboolean valid;
	GtkTreeIter iter;
	device_t *dev;
	device_group_t *devgrp;
	wrap_device_t *wdev;
	wrap_group_t *wgrp;

	/* clear out the iconview */
	valid = gtk_tree_model_get_iter_first(iconview_model, &iter);
	while (valid)
		valid = gtk_list_store_remove(GTK_LIST_STORE(iconview_model),
					      &iter);

	dev = find_device_byuid(uid);
	if (dev) {
		add_device_devicelist_model(dev, iconview_model, &iter,
					    "iconview1");
		return;
	}
	devgrp = find_devgroup_byuid(uid);
	if (devgrp) {
		TAILQ_FOREACH(wgrp, &devgrp->children, nextg)
			add_group_devicelist_model(wgrp->group, iconview_model,
						   &iter, "iconview1");
			
		TAILQ_FOREACH(wdev, &devgrp->members, next)
			add_device_devicelist_model(wdev->dev, iconview_model,
						    &iter, "iconview1");
		return;
	}
	if (strcmp(uid, INVALID_UID) == 0) {
		TAILQ_FOREACH(dev, &alldevs, next_all) {
			add_device_devicelist_model(dev, iconview_model, &iter,
					    "iconview1");
		}
		return;
	}
	return;
}

/**
   \brief Log something to the status bar
   \param context one of CTX_*
   \param msg format string
   \param ... arguments
*/

void log_status(char *context, char *msg, ...)
{
	char buf[2048];
	va_list args;
	GtkWidget *statusbar;
	guint ctx;

	if (strcmp(context, CTX_DEBUG) == 0 && !debugmode)
		return;

	statusbar = lookup_widget(main_window, "statusbar1");
	ctx = gtk_statusbar_get_context_id(GTK_STATUSBAR(statusbar),
					   context);

	va_start(args, msg);
	vsprintf(buf, msg, args);
	va_end(args);
	gtk_statusbar_push(GTK_STATUSBAR(statusbar), ctx, buf);
}

/**
   \brief Log something to the status bar and LOG
   \param level log level
   \param msg format string
   \param ... arguments
 */

void TLOG(int level, char *msg, ...)
{
	char buf[2048];
	va_list args;

	va_start(args, msg);
	vsprintf(buf, msg, args);
	va_end(args);

	switch (level) {
	case LOG_DEBUG:
		log_status(CTX_DEBUG, buf);
		break;
	case LOG_NOTICE:
		log_status(CTX_NOTICE, buf);
		break;
	default:
		log_status(CTX_ERROR, buf);
		break;
	}
	LOG(level, buf);
}

/**
   \brief Build the main window
*/

GtkWidget *create_window1(void)
{
	GtkWidget *window1;
	GtkWidget *vbox1;
	GtkWidget *menubar1, *menuitem1, *menuitem1_menu;
	GtkWidget *open1, *save1;
	GtkWidget *savecfg, *savedev, *savegrp;
	GtkWidget *req_devlist;
	GtkWidget *quit1;
/*
	GtkWidget *enable_datastream1;
	GtkWidget *menuitem2, *menuitem2_menu;
	GtkWidget *cut1, *copy1, *paste1, *delete1;
*/
	GtkWidget *menuitem4, *menuitem4_menu, *about1;
	GtkWidget *notebook1;
	GtkWidget *hbox1;
	GtkWidget *scrolledwindow1, *hpaned1, *devicetree;
	GtkWidget *scrolledwindow3, *iconview1, *page1_title;
	GtkWidget *scrolledwindow2, *ddscrolledwindow;
	GtkWidget *treeview1, *page2_title, *hpaned2, *devicetree2;
	GtkWidget *table1, *dd_col0_title, *dd_col1_title;
	GtkWidget *dd_save_button, *dd_reset_button;
	GtkWidget *page3_title;
/*
	GtkWidget *scrolledwindow4;
	GtkWidget *datastream_textview;
	GtkWidget *page4_title;
*/
	GtkWidget *statusbar1;
	GtkAccelGroup *accel_group;
	GList *icon_list = NULL;
	GdkPixbuf *icon16, *icon32, *icon48;
	int i;

	accel_group = gtk_accel_group_new();

	window1 = gtk_window_new(GTK_WINDOW_TOPLEVEL);
	gtk_window_set_title(GTK_WINDOW(window1), _("gtk-gnhast"));
	gtk_window_resize(GTK_WINDOW(window1), 750, 500);

	load_icons();

	icon16 = create_pixbuf("gnhast-icon-16.png");
	icon32 = create_pixbuf("gnhast-icon-32.png");
	icon48 = create_pixbuf("gnhast-icon-48.png");
	icon_list = g_list_append(icon_list, icon16);
	icon_list = g_list_append(icon_list, icon32);
	icon_list = g_list_append(icon_list, icon48);
	gtk_window_set_icon_list(GTK_WINDOW(window1), icon_list);

	vbox1 = gtk_vbox_new(FALSE, 0);
	gtk_widget_show(vbox1);
	gtk_container_add(GTK_CONTAINER(window1), vbox1);

	GLADE_HOOKUP_OBJECT_NO_REF(window1, window1, "window1");
	GLADE_HOOKUP_OBJECT(window1, vbox1, "vbox1");

	/**** Top Menu ****/

	menubar1 = gtk_menu_bar_new();
	gtk_widget_show(menubar1);
	gtk_box_pack_start(GTK_BOX(vbox1), menubar1, FALSE, FALSE, 0);
	GLADE_HOOKUP_OBJECT(window1, menubar1, "menubar1");

	menuitem1 = gtk_menu_item_new_with_mnemonic(_("_File"));
	gtk_widget_show(menuitem1);
	gtk_container_add(GTK_CONTAINER(menubar1), menuitem1);
	GLADE_HOOKUP_OBJECT(window1, menuitem1, "menuitem1");

	menuitem1_menu = gtk_menu_new();
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(menuitem1), menuitem1_menu);
	GLADE_HOOKUP_OBJECT(window1, menuitem1_menu, "menuitem1_menu");

	open1 = gtk_image_menu_item_new_from_stock(GTK_STOCK_CONNECT,
						   accel_group);
	gtk_widget_show(open1);
	gtk_menu_item_set_label(GTK_MENU_ITEM(open1), "Connect to gnhastd");
	gtk_container_add(GTK_CONTAINER(menuitem1_menu), open1);
	g_signal_connect((gpointer)open1, "activate",
			  G_CALLBACK(on_open1_activate), NULL);
	GLADE_HOOKUP_OBJECT(window1, open1, "open1");

	save1 = gtk_image_menu_item_new_from_stock(GTK_STOCK_APPLY,
						   accel_group);
	gtk_widget_show(save1);
	gtk_menu_item_set_label(GTK_MENU_ITEM(save1), "Save Group Layout");
	gtk_container_add(GTK_CONTAINER(menuitem1_menu), save1);
	g_signal_connect((gpointer)save1, "activate",
			  G_CALLBACK(on_save1_activate), NULL);
	GLADE_HOOKUP_OBJECT(window1, save1, "save1");
	
/*
	enable_datastream1 =
	gtk_check_menu_item_new_with_mnemonic(_("Enable Datastream"));
	gtk_widget_show(enable_datastream1);
	gtk_container_add(GTK_CONTAINER(menuitem1_menu), enable_datastream1);
	g_signal_connect((gpointer)enable_datastream1, "activate",
			  G_CALLBACK(on_enable_datastream1_activate), NULL);
	GLADE_HOOKUP_OBJECT(window1, enable_datastream1, "enable_datastream1");
*/

	/*** REQUEST DEVLIST ***/
	req_devlist = gtk_image_menu_item_new_from_stock(GTK_STOCK_REVERT_TO_SAVED, accel_group);
	gtk_widget_show(req_devlist);
	gtk_menu_item_set_label(GTK_MENU_ITEM(req_devlist), "Rescan Devices");
	gtk_container_add(GTK_CONTAINER(menuitem1_menu), req_devlist);
	g_signal_connect((gpointer)req_devlist, "activate",
			 G_CALLBACK(req_devlist_activate), NULL);
	GLADE_HOOKUP_OBJECT(window1, req_devlist, "req_devlist");

	/*** SAVE CONFIG ***/
	savecfg = gtk_image_menu_item_new_from_stock(GTK_STOCK_SAVE,
						     accel_group);
	gtk_menu_item_set_label(GTK_MENU_ITEM(savecfg), "Save RC File");
	gtk_widget_show(savecfg);
	gtk_container_add(GTK_CONTAINER(menuitem1_menu), savecfg);
	g_signal_connect((gpointer)savecfg, "activate",
			  G_CALLBACK(on_savecfg_activate), NULL);
	GLADE_HOOKUP_OBJECT(window1, savecfg, "savecfg");

	/*** SAVE GROUPFILE ***/
	savegrp = gtk_image_menu_item_new_from_stock(GTK_STOCK_CONVERT,
						     accel_group);
	gtk_menu_item_set_label(GTK_MENU_ITEM(savegrp),
				"Save Group Conf File");
	gtk_widget_show(savegrp);
	gtk_container_add(GTK_CONTAINER(menuitem1_menu), savegrp);
	g_signal_connect((gpointer)savegrp, "activate",
			  G_CALLBACK(on_savegrp_activate), NULL);
	GLADE_HOOKUP_OBJECT(window1, savegrp, "savegrp");

	/*** SAVE DEVFILE ***/
	savedev = gtk_image_menu_item_new_from_stock(GTK_STOCK_EXECUTE,
						     accel_group);
	gtk_menu_item_set_label(GTK_MENU_ITEM(savedev),
				"Save Device Conf File");
	gtk_widget_show(savedev);
	gtk_container_add(GTK_CONTAINER(menuitem1_menu), savedev);
	g_signal_connect((gpointer)savedev, "activate",
			  G_CALLBACK(on_savedev_activate), NULL);
	GLADE_HOOKUP_OBJECT(window1, savedev, "savedev");

	/*** QUIT ***/
	quit1 = gtk_image_menu_item_new_from_stock(GTK_STOCK_QUIT,
						   accel_group);
	gtk_widget_show(quit1);
	gtk_container_add(GTK_CONTAINER(menuitem1_menu), quit1);
	g_signal_connect((gpointer)quit1, "activate",
			  G_CALLBACK(on_quit1_activate), NULL);
	GLADE_HOOKUP_OBJECT(window1, quit1, "quit1");

/*
	menuitem2 = gtk_menu_item_new_with_mnemonic(_("_Edit"));
	gtk_widget_show(menuitem2);
	gtk_container_add(GTK_CONTAINER(menubar1), menuitem2);

	menuitem2_menu = gtk_menu_new();
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(menuitem2), menuitem2_menu);

	cut1 = gtk_image_menu_item_new_from_stock("gtk-cut", accel_group);
	gtk_widget_show(cut1);
	gtk_container_add(GTK_CONTAINER(menuitem2_menu), cut1);

	copy1 = gtk_image_menu_item_new_from_stock("gtk-copy", accel_group);
	gtk_widget_show(copy1);
	gtk_container_add(GTK_CONTAINER(menuitem2_menu), copy1);

	paste1 = gtk_image_menu_item_new_from_stock("gtk-paste", accel_group);
	gtk_widget_show(paste1);
	gtk_container_add(GTK_CONTAINER(menuitem2_menu), paste1);

	delete1 = gtk_image_menu_item_new_from_stock("gtk-delete", accel_group);
	gtk_widget_show(delete1);
	gtk_container_add(GTK_CONTAINER(menuitem2_menu), delete1);
	GLADE_HOOKUP_OBJECT(window1, menuitem2, "menuitem2");
	GLADE_HOOKUP_OBJECT(window1, menuitem2_menu, "menuitem2_menu");
	GLADE_HOOKUP_OBJECT(window1, cut1, "cut1");
	GLADE_HOOKUP_OBJECT(window1, copy1, "copy1");
	GLADE_HOOKUP_OBJECT(window1, paste1, "paste1");
	GLADE_HOOKUP_OBJECT(window1, delete1, "delete1");
	g_signal_connect((gpointer)cut1, "activate",
			  G_CALLBACK(on_cut1_activate), NULL);
	g_signal_connect((gpointer)copy1, "activate",
			  G_CALLBACK(on_copy1_activate), NULL);
	g_signal_connect((gpointer)paste1, "activate",
			  G_CALLBACK(on_paste1_activate), NULL);
	g_signal_connect((gpointer)delete1, "activate",
			  G_CALLBACK(on_delete1_activate), NULL);

*/

	menuitem4 = gtk_menu_item_new_with_mnemonic(_("_Help"));
	gtk_widget_show(menuitem4);
	gtk_container_add(GTK_CONTAINER(menubar1), menuitem4);
	GLADE_HOOKUP_OBJECT(window1, menuitem4, "menuitem4");

	menuitem4_menu = gtk_menu_new();
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(menuitem4), menuitem4_menu);
	GLADE_HOOKUP_OBJECT(window1, menuitem4_menu, "menuitem4_menu");

	about1 = gtk_image_menu_item_new_from_stock(GTK_STOCK_ABOUT,
						    accel_group);
	gtk_widget_show(about1);
	gtk_container_add(GTK_CONTAINER(menuitem4_menu), about1);
	g_signal_connect((gpointer)about1, "activate",
			  G_CALLBACK(on_about1_activate), NULL);
	GLADE_HOOKUP_OBJECT(window1, about1, "about1");

	/**** Main Window Notebook ****/

	notebook1 = gtk_notebook_new();
	gtk_widget_show(notebook1);
	gtk_box_pack_start(GTK_BOX(vbox1), notebook1, TRUE, TRUE, 0);
	GLADE_HOOKUP_OBJECT(window1, notebook1, "notebook1");

	hbox1 = gtk_hbox_new(FALSE, 0);
	gtk_widget_show(hbox1);
	gtk_container_add(GTK_CONTAINER(notebook1), hbox1);
	GLADE_HOOKUP_OBJECT(window1, hbox1, "hbox1");

	/**** Overview Pane ****/

	hpaned1 = gtk_hpaned_new();
	gtk_widget_show(hpaned1);
	gtk_box_pack_start(GTK_BOX(hbox1), hpaned1, TRUE, TRUE, 0);
	gtk_paned_set_position(GTK_PANED(hpaned1), 0);
	GLADE_HOOKUP_OBJECT(window1, hpaned1, "hpaned1");

	scrolledwindow1 = gtk_scrolled_window_new(NULL, NULL);
	gtk_widget_show(scrolledwindow1);
	gtk_paned_pack1(GTK_PANED(hpaned1), scrolledwindow1, FALSE, TRUE);
	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolledwindow1), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scrolledwindow1), GTK_SHADOW_IN);
	GLADE_HOOKUP_OBJECT(window1, scrolledwindow1, "scrolledwindow1");

	/* The device tree for the Overview pane */
	devicetree = create_devicetree_view_and_model();
	gtk_widget_show(devicetree);
	overview_select =
		gtk_tree_view_get_selection(GTK_TREE_VIEW(devicetree));
	g_signal_connect((gpointer)overview_select, "changed",
			 G_CALLBACK(overview_listitem_selected), NULL);
	gtk_tree_view_enable_model_drag_dest(GTK_TREE_VIEW(devicetree),
					     drag_targets,
					     G_N_ELEMENTS(drag_targets),
					     GDK_ACTION_COPY);
	g_signal_connect(devicetree, "drag_data_received",
			 G_CALLBACK(treeview_on_drag_rec), NULL);
	g_signal_connect(devicetree, "key-press-event",
			 G_CALLBACK(treeview_keypress_cb), NULL);
	g_signal_connect(devicetree, "button-press-event",
			 G_CALLBACK(treeview_buttonpress_cb), NULL);
	GLADE_HOOKUP_OBJECT(window1, devicetree, "devicetree");
	gtk_container_add(GTK_CONTAINER(scrolledwindow1), devicetree);

	/* The iconview pane */
	scrolledwindow3 = gtk_scrolled_window_new(NULL, NULL);
	gtk_widget_show(scrolledwindow3);
	gtk_paned_pack2(GTK_PANED(hpaned1), scrolledwindow3, TRUE, TRUE);
	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolledwindow3), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scrolledwindow3), GTK_SHADOW_IN);
	GLADE_HOOKUP_OBJECT(window1, scrolledwindow3, "scrolledwindow3");

	iconview_model = create_listview_model();
	iconview1 = gtk_icon_view_new_with_model(iconview_model);
	gtk_icon_view_set_text_column(GTK_ICON_VIEW(iconview1), LIST_UID_COL);
	gtk_icon_view_set_pixbuf_column(GTK_ICON_VIEW(iconview1),
					LIST_PIXBUF_COL);
	gtk_icon_view_set_tooltip_column(GTK_ICON_VIEW(iconview1),
					 LIST_NAME_COL);
	gtk_widget_show(iconview1);
	gtk_container_add(GTK_CONTAINER(scrolledwindow3), iconview1);
	gtk_icon_view_set_selection_mode(GTK_ICON_VIEW(iconview1),
					 GTK_SELECTION_SINGLE);
	gtk_icon_view_enable_model_drag_source(GTK_ICON_VIEW(iconview1),
					       GDK_BUTTON1_MASK,
					       drag_targets,
					       G_N_ELEMENTS(drag_targets),
					       GDK_ACTION_COPY);
	g_signal_connect((gpointer)iconview1, "item-activated",
			 G_CALLBACK(iconview_icon_activated), NULL);
	g_signal_connect((gpointer)iconview1, "drag-data-get",
			 G_CALLBACK(on_icon_drag_data_get), NULL);
	GLADE_HOOKUP_OBJECT(window1, iconview1, "iconview1");


	page1_title = gtk_label_new(_("Overview"));
	gtk_widget_show(page1_title);
	gtk_notebook_set_tab_label(GTK_NOTEBOOK(notebook1),
				   gtk_notebook_get_nth_page(GTK_NOTEBOOK(notebook1), 0), page1_title);
	GLADE_HOOKUP_OBJECT(window1, page1_title, "page1_title");

	/**** List View Pane ****/

	scrolledwindow2 = gtk_scrolled_window_new(NULL, NULL);
	gtk_widget_show(scrolledwindow2);
	gtk_container_add(GTK_CONTAINER(notebook1), scrolledwindow2);
	gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scrolledwindow2), GTK_SHADOW_IN);
	GLADE_HOOKUP_OBJECT(window1, scrolledwindow2, "scrolledwindow2");

	treeview1 = gtk_tree_view_new();
	create_list_view(treeview1, FALSE);
	gtk_widget_show(treeview1);
	gtk_container_add(GTK_CONTAINER(scrolledwindow2), treeview1);
	GLADE_HOOKUP_OBJECT(window1, treeview1, "treeview1");

	page2_title = gtk_label_new(_("List View"));
	GLADE_HOOKUP_OBJECT(window1, page2_title, "page2_title");

	devicelist_model = create_listview_model();
	gtk_tree_view_set_model(GTK_TREE_VIEW(treeview1), devicelist_model);

	gtk_widget_show(page2_title);
	gtk_notebook_set_tab_label(GTK_NOTEBOOK(notebook1), gtk_notebook_get_nth_page(GTK_NOTEBOOK(notebook1), 1), page2_title);

	/**** Device Details Pane ****/

	hpaned2 = gtk_hpaned_new();
	gtk_widget_show(hpaned2);
	gtk_container_add(GTK_CONTAINER(notebook1), hpaned2);
	gtk_paned_set_position(GTK_PANED(hpaned2), 0);
	GLADE_HOOKUP_OBJECT(window1, hpaned2, "hpaned2");

	ddscrolledwindow = gtk_scrolled_window_new(NULL, NULL);
	gtk_widget_show(ddscrolledwindow);
	gtk_paned_pack1(GTK_PANED(hpaned2), ddscrolledwindow, FALSE, TRUE);

	/* Device tree for the Device Details pane */
	devicetree2 = create_devicetree_view_and_model();
	gtk_widget_show(devicetree2);
	gtk_container_add(GTK_CONTAINER(ddscrolledwindow), devicetree2);
	GLADE_HOOKUP_OBJECT(window1, devicetree2, "devicetree2");

	dd_select = gtk_tree_view_get_selection(GTK_TREE_VIEW(devicetree2));
	g_signal_connect(dd_select, "changed",
			 G_CALLBACK(dd_listitem_selected), NULL);

	table1 = gtk_table_new(15, 2, FALSE);
	gtk_widget_show(table1);
	gtk_paned_pack2(GTK_PANED(hpaned2), table1, FALSE, FALSE);
	gtk_container_set_border_width(GTK_CONTAINER(table1), 2);
	gtk_table_set_row_spacings(GTK_TABLE(table1), 3);
	gtk_table_set_col_spacings(GTK_TABLE(table1), 2);
	GLADE_HOOKUP_OBJECT(window1, table1, "table1");

	dd_col0_title = gtk_label_new(_("Field"));
	gtk_widget_show(dd_col0_title);
	gtk_table_attach(GTK_TABLE(table1), dd_col0_title, 0, 1, 0, 1,
			 (GtkAttachOptions)(GTK_FILL),
			 (GtkAttachOptions)(0), 0, 0);
	gtk_misc_set_alignment(GTK_MISC(dd_col0_title), 0, 0.5);
	GLADE_HOOKUP_OBJECT(window1, dd_col0_title, "dd_col0_title");

	dd_col1_title = gtk_label_new(_("Value"));
	gtk_widget_show(dd_col1_title);
	gtk_table_attach(GTK_TABLE(table1), dd_col1_title, 1, 2, 0, 1,
			 (GtkAttachOptions)(GTK_FILL),
			 (GtkAttachOptions)(0), 0, 0);
	gtk_misc_set_alignment(GTK_MISC(dd_col1_title), 0, 0.5);
	GLADE_HOOKUP_OBJECT(window1, dd_col1_title, "dd_col1_title");

	for (i = DD_UID; i < NROF_DD; i++) {
		/* label */
		dd_fields[i].label = gtk_label_new(dd_fields[i].text);
		gtk_widget_show(dd_fields[i].label);
		gtk_table_attach(GTK_TABLE(table1), dd_fields[i].label,
				 0, 1, i, i+1, (GtkAttachOptions)(GTK_FILL),
				 (GtkAttachOptions)(0), 0, 0);
		gtk_misc_set_alignment(GTK_MISC(dd_fields[i].label), 0, 0.5);
		/* entry box */ 
		dd_fields[i].entry = gtk_entry_new();
		gtk_widget_show(dd_fields[i].entry);
		gtk_table_attach(GTK_TABLE(table1), dd_fields[i].entry,
				 1, 2, i, i+1,
				 (GtkAttachOptions)(GTK_EXPAND | GTK_FILL),
				 (GtkAttachOptions)(0), 0, 0);
		gtk_editable_set_editable(GTK_EDITABLE(dd_fields[i].entry),
					  dd_fields[i].editable);
	}
	dd_save_button = gtk_button_new_with_label("Save Changes");
	gtk_widget_show(dd_save_button);
	gtk_table_attach(GTK_TABLE(table1), dd_save_button,
			 0, 1, NROF_DD, NROF_DD + 1,
			 (GtkAttachOptions)(GTK_FILL),
			 (GtkAttachOptions)(0), 0, 0);
	g_signal_connect(GTK_BUTTON(dd_save_button), "clicked",
			  G_CALLBACK(on_dd_save_activate), NULL);	

	dd_reset_button = gtk_button_new_with_label("Reset");
	gtk_widget_show(dd_reset_button);
	gtk_table_attach(GTK_TABLE(table1), dd_reset_button,
			 1, 2, NROF_DD, NROF_DD + 1,
			 (GtkAttachOptions)(GTK_FILL),
			 (GtkAttachOptions)(0), 0, 0);
	g_signal_connect((gpointer)dd_reset_button, "clicked",
			  G_CALLBACK(on_dd_reset_activate), NULL);

	page3_title = gtk_label_new(_("Device Details"));
	gtk_widget_show(page3_title);
	gtk_notebook_set_tab_label(GTK_NOTEBOOK(notebook1), gtk_notebook_get_nth_page(GTK_NOTEBOOK(notebook1), 2), page3_title);
	GLADE_HOOKUP_OBJECT(window1, page3_title, "page3_title");

	/**** Datastream Pane ****/
/*
	scrolledwindow4 = gtk_scrolled_window_new(NULL, NULL);
	gtk_widget_show(scrolledwindow4);
	gtk_container_add(GTK_CONTAINER(notebook1), scrolledwindow4);
	gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scrolledwindow4), GTK_SHADOW_IN);
	GLADE_HOOKUP_OBJECT(window1, scrolledwindow4, "scrolledwindow4");

	datastream_textview = gtk_text_view_new();
	gtk_widget_show(datastream_textview);
	gtk_container_add(GTK_CONTAINER(scrolledwindow4), datastream_textview);
	gtk_text_view_set_editable(GTK_TEXT_VIEW(datastream_textview), FALSE);
	GLADE_HOOKUP_OBJECT(window1, datastream_textview, "datastream_textview");

	page4_title = gtk_label_new(_("Datastream"));
	gtk_widget_show(page4_title);
	gtk_notebook_set_tab_label(GTK_NOTEBOOK(notebook1), gtk_notebook_get_nth_page(GTK_NOTEBOOK(notebook1), 3), page4_title);
	GLADE_HOOKUP_OBJECT(window1, page4_title, "page4_title");
*/

	statusbar1 = gtk_statusbar_new();
	gtk_widget_show(statusbar1);
	gtk_box_pack_start(GTK_BOX(vbox1), statusbar1, FALSE, FALSE, 0);
	GLADE_HOOKUP_OBJECT(window1, statusbar1, "statusbar1");

	gtk_window_add_accel_group(GTK_WINDOW(window1), accel_group);

	return window1;
}

/**
   \brief Ask the user to name the group to insert
*/

GtkWidget *create_insert_group_dialog(void)
{
	GtkWidget *ig_dialog, *vbox, *hbox, *vbox1, *vbox2;
	GtkWidget *new_group_name_entry, *label1;
	GtkWidget *new_group_uid_entry, *label2;

	ig_dialog = gtk_dialog_new_with_buttons("Create New Group",
						GTK_WINDOW(main_window), 0,
						GTK_STOCK_OK,
						GTK_RESPONSE_ACCEPT,
						GTK_STOCK_CANCEL,
						GTK_RESPONSE_REJECT,
						NULL);

	vbox = gtk_dialog_get_content_area(GTK_DIALOG(ig_dialog));
	gtk_widget_show(vbox);
	hbox = gtk_hbox_new(TRUE, 5);
	gtk_widget_show(hbox);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 5);
	vbox1 = gtk_vbox_new(TRUE, 5);
	gtk_widget_show(vbox1);
	gtk_box_pack_start(GTK_BOX(hbox), vbox1, FALSE, FALSE, 5);
	vbox2 = gtk_vbox_new(TRUE, 5);
	gtk_widget_show(vbox2);
	gtk_box_pack_end(GTK_BOX(hbox), vbox2, FALSE, FALSE, 5);

	label1 = gtk_label_new("New Group Name:");
	gtk_widget_show(label1);
	gtk_box_pack_start(GTK_BOX(vbox1), label1, FALSE, FALSE, 5);
	label2 = gtk_label_new("New Group UID:");
	gtk_widget_show(label2);
	gtk_box_pack_end(GTK_BOX(vbox1), label2, FALSE, FALSE, 5);

	new_group_name_entry = gtk_entry_new();
	gtk_widget_show(new_group_name_entry);
	GLADE_HOOKUP_OBJECT(ig_dialog, new_group_name_entry, "groupname");
	gtk_box_pack_start(GTK_BOX(vbox2), new_group_name_entry, FALSE,
			   FALSE, 5);
	new_group_uid_entry = gtk_entry_new();
	gtk_widget_show(new_group_uid_entry);
	GLADE_HOOKUP_OBJECT(ig_dialog, new_group_uid_entry, "groupuid");
	gtk_box_pack_end(GTK_BOX(vbox2), new_group_uid_entry, FALSE,
			   FALSE, 5);

	return ig_dialog;
}

/**
   \brief Build and display a fast error dialog
   \param msg format string
   \param ... arguments
*/

void error_dialog(GtkWidget *parent, char *msg, ...)
{
	char buf[2048];
	va_list args;
	GtkWidget *dialog;

	va_start(args, msg);
	vsprintf(buf, msg, args);
	va_end(args);
	dialog = gtk_message_dialog_new(GTK_WINDOW(parent),
					GTK_DIALOG_DESTROY_WITH_PARENT,
					GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE,
					buf);
	gtk_dialog_run(GTK_DIALOG(dialog));
	gtk_widget_destroy(dialog);
}

/**
   \brief Build the connect to gnhastd server dialog
   \return built widget
*/

GtkWidget* create_dialog1(void)
{
	GtkWidget *dialog1;
	GtkWidget *dialog_vbox1;
	GtkWidget *fixed1;
	GtkWidget *dialog_server_entry;
	GtkWidget *dialog_port_entry;
	GtkWidget *label9;
	GtkWidget *label13;

	dialog1 = gtk_dialog_new_with_buttons("Connect to gnhastd server",
					      GTK_WINDOW(main_window), 0,
					      GTK_STOCK_OK,
					      GTK_RESPONSE_OK,
					      GTK_STOCK_CANCEL,
					      GTK_RESPONSE_REJECT,
					      NULL);

	gtk_dialog_set_has_separator(GTK_DIALOG(dialog1), FALSE);

	dialog_vbox1 = gtk_dialog_get_content_area(GTK_DIALOG(dialog1));
	gtk_widget_show(dialog_vbox1);

	fixed1 = gtk_fixed_new();
	gtk_widget_show(fixed1);
	gtk_box_pack_start(GTK_BOX(dialog_vbox1), fixed1, TRUE, TRUE, 0);

	dialog_server_entry = gtk_entry_new();
	gtk_widget_show(dialog_server_entry);
	gtk_fixed_put(GTK_FIXED(fixed1), dialog_server_entry, 128, 16);
	gtk_widget_set_size_request(dialog_server_entry, 272, 24);

	dialog_port_entry = gtk_entry_new();
	gtk_widget_show(dialog_port_entry);
	gtk_entry_set_text(GTK_ENTRY(dialog_port_entry), "2920");
	gtk_fixed_put(GTK_FIXED(fixed1), dialog_port_entry, 128, 48);
	gtk_widget_set_size_request(dialog_port_entry, 272, 24);

	label9 = gtk_label_new(_("gnhastd server"));
	gtk_widget_show(label9);
	gtk_fixed_put(GTK_FIXED(fixed1), label9, 8, 16);
	gtk_widget_set_size_request(label9, 120, 24);

	label13 = gtk_label_new(_("gnhastd port"));
	gtk_widget_show(label13);
	gtk_fixed_put(GTK_FIXED(fixed1), label13, 8, 48);
	gtk_widget_set_size_request(label13, 120, 24);

	/* Store pointers to all widgets, for use by lookup_widget(). */
	GLADE_HOOKUP_OBJECT_NO_REF(dialog1, dialog1, "dialog1");
	GLADE_HOOKUP_OBJECT(dialog1, dialog_server_entry, "dialog_server_entry");
	GLADE_HOOKUP_OBJECT(dialog1, dialog_port_entry, "dialog_port_entry");

	return dialog1;
}

/**
   \brief Fire up the about dialog
*/

void show_aboutdialog(void)
{
	GtkWidget *aboutdialog1;
	GdkPixbuf *logo;
	const gchar *authors[] = {
		"Tim Rightnour",
		NULL
	};

	/* TRANSLATORS: Replace this string with your names, one name per line. */
	gchar *translators = _("translator-credits");

	aboutdialog1 = gtk_about_dialog_new();

	gtk_container_set_border_width(GTK_CONTAINER(aboutdialog1), 5);
	gtk_window_set_destroy_with_parent(GTK_WINDOW(aboutdialog1), TRUE);

	logo = create_pixbuf("gnhast-logo.png");
	gtk_about_dialog_set_logo(GTK_ABOUT_DIALOG(aboutdialog1), logo);

	gtk_about_dialog_set_version(GTK_ABOUT_DIALOG(aboutdialog1), VERSION);
	gtk_about_dialog_set_name(GTK_ABOUT_DIALOG(aboutdialog1), _("gtk-gnhast"));
	gtk_about_dialog_set_copyright(GTK_ABOUT_DIALOG(aboutdialog1), _(" Copyright(c) 2014\nTim Rightnour.  All rights reserved."));
	gtk_about_dialog_set_comments(GTK_ABOUT_DIALOG(aboutdialog1), _("Gtk-gnhast is a handly little tool for editing and viewing your home automation data."));
	gtk_about_dialog_set_license(GTK_ABOUT_DIALOG(aboutdialog1), _("Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n \n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n3. The name of Tim Rightnour may not be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY TIM RIGHTNOUR ``AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL TIM RIGHTNOUR BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."));
	gtk_about_dialog_set_wrap_license(GTK_ABOUT_DIALOG(aboutdialog1), TRUE);
	gtk_about_dialog_set_website(GTK_ABOUT_DIALOG(aboutdialog1), "https://sourceforge.net/p/gnhast/");
	gtk_about_dialog_set_website_label(GTK_ABOUT_DIALOG(aboutdialog1), _("gnhast website"));
	gtk_about_dialog_set_authors(GTK_ABOUT_DIALOG(aboutdialog1), authors);
	gtk_about_dialog_set_translator_credits(GTK_ABOUT_DIALOG(aboutdialog1), translators);

	/* Store pointers to all widgets, for use by lookup_widget(). */
	GLADE_HOOKUP_OBJECT_NO_REF(aboutdialog1, aboutdialog1, "aboutdialog1");

	gtk_dialog_run(GTK_DIALOG(aboutdialog1));
	gtk_widget_destroy(aboutdialog1);
}
